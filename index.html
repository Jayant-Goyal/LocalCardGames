<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Card Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
        }
        .card-base {
            width: 80px;
            height: 120px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid white;
        }
        .card-base:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }
        .player-hand .card-base {
            margin: 0 -20px;
        }
        .opponent-card {
            width: 40px;
            height: 60px;
            background-color: #4A5568;
            border: 2px solid white;
            border-radius: 4px;
        }
        .choice-picker-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid white;
            transition: transform 0.2s;
            font-size: 1.5rem;
        }
        .choice-picker-button:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full h-full max-w-2xl mx-auto p-4 flex flex-col">

        <!-- Game Selection Screen -->
        <div id="game-selection" class="flex flex-col items-center justify-center text-center h-full">
            <h1 class="text-5xl font-bold mb-4">Pixel Card Games</h1>
            <p class="text-gray-400 mb-8">Choose a game to play</p>
            <div id="game-list" class="space-y-4">
                <!-- Game buttons will be inserted here by JS -->
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby" class="hidden flex-col items-center justify-center text-center h-full">
            <button id="back-to-selection" class="absolute top-4 left-4 text-gray-400 hover:text-white">&larr; Back</button>
            <h1 id="lobby-title" class="text-5xl font-bold mb-4"></h1>
            <p class="text-gray-400 mb-8">Play with friends from anywhere!</p>
            <div id="auth-loading" class="text-lg">Connecting...</div>
            <div id="lobby-actions" class="hidden">
                <button id="create-game-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-xl mb-4 w-64">
                    Create Game
                </button>
                <div class="flex flex-col items-center">
                    <input type="text" id="game-id-input" placeholder="Enter Game ID" class="bg-gray-700 border border-gray-600 rounded-lg text-center text-white py-3 px-4 mb-2 w-64 uppercase" maxlength="5">
                    <button id="join-game-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg text-xl w-64">
                        Join Game
                    </button>
                </div>
            </div>
            <p id="error-message" class="text-red-400 mt-4"></p>
        </div>

        <!-- Game Screen -->
        <div id="game-board" class="hidden flex-col h-full w-full">
            <div id="opponents-area" class="flex justify-around items-center h-24"></div>
            <div class="flex-grow flex items-center justify-center space-x-4 my-4">
                <div id="draw-deck" class="card-base bg-gray-800 flex items-center justify-center">
                    <div id="draw-deck-content" class="text-4xl font-bold text-indigo-400"></div>
                </div>
                <div id="discard-pile" class="card-base"></div>
            </div>
            <div class="text-center mb-2">
                <p id="game-info" class="text-lg font-medium text-gray-300"></p>
                <div class="h-10">
                    <p id="game-log" class="text-amber-300 font-semibold text-sm h-full overflow-y-auto"></p>
                </div>
            </div>
            <div class="h-40 flex items-center justify-center">
                 <div id="player-hand" class="flex justify-center items-end"></div>
            </div>
            <div class="text-center mt-auto pt-2">
                <p class="text-gray-500">Game ID: <span id="game-id-display" class="font-bold tracking-widest"></span></p>
                 <button id="leave-game-btn" class="text-xs bg-red-800 hover:bg-red-700 px-3 py-1 rounded mt-1">Leave Game</button>
            </div>
        </div>

        <!-- Modals -->
        <div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
            <div class="text-white text-2xl" id="loading-text"></div>
        </div>
        <div id="choice-picker-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-center">
                <h3 id="choice-title" class="text-2xl font-bold mb-4"></h3>
                <div id="choice-buttons" class="flex space-x-4"></div>
            </div>
        </div>
        <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-xl text-center">
                <h3 class="text-4xl font-bold mb-4">Game Over!</h3>
                <p id="winner-text" class="text-2xl mb-6"></p>
                <button id="play-again-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-xl">Play Again</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, writeBatch, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // =================================================================================
        // GAME DEFINITIONS (This is where you can add new games)
        // =================================================================================
        const GAME_DEFINITIONS = {
            'pixel-cards': {
                name: 'Pixel Cards',
                description: 'Match colors and numbers to empty your hand.',
                minPlayers: 2,
                maxPlayers: 4,
                initialHandSize: 7,
                deck: function() {
                    const deck = [];
                    const COLORS = ['red', 'green', 'blue', 'yellow'];
                    const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
                    for (const color of COLORS) {
                        for (const value of VALUES) {
                            deck.push({ color, value });
                            if (value !== '0') deck.push({ color, value });
                        }
                    }
                    for (let i = 0; i < 4; i++) {
                        deck.push({ color: 'wild', value: 'wild' });
                        deck.push({ color: 'wild', value: 'wild4' });
                    }
                    return deck;
                },
                getDisplayInfo: function(card) {
                    const colorMap = { red: 'bg-red-500', green: 'bg-green-500', blue: 'bg-blue-500', yellow: 'bg-yellow-500', wild: 'bg-gray-700'};
                    const symbolMap = { skip: 'ðŸš«', reverse: 'ðŸ”„', draw2: '+2', wild: 'ðŸŽ¨', wild4: '+4' };
                    return {
                        backgroundColor: colorMap[card.color] || 'bg-gray-600',
                        content: `<span class="${card.value.length > 2 ? 'text-xl' : ''}">${symbolMap[card.value] || card.value}</span>`,
                        textColor: 'text-white'
                    };
                },
                rules: {
                    isPlayable: function(card, topCard, activeValue) { // activeValue is the current color
                        return card.color === 'wild' || card.color === activeValue || card.value === topCard.value;
                    },
                    getWildCardChoices: function() {
                        return { title: "Choose a color", choices: [
                            { value: 'red', display: '<div class="w-full h-full bg-red-500 rounded-full"></div>' },
                            { value: 'green', display: '<div class="w-full h-full bg-green-500 rounded-full"></div>' },
                            { value: 'blue', display: '<div class="w-full h-full bg-blue-500 rounded-full"></div>' },
                            { value: 'yellow', display: '<div class="w-full h-full bg-yellow-500 rounded-full"></div>' }
                        ]};
                    },
                    onPlay: async function(transaction, gameState, card, chosenValue, player, playerHandRef, gameRef) {
                        // This function defines the logic for card effects
                        let nextPlayerIndex = gameState.players.findIndex(p => p.uid === player.uid);
                        
                        // Handle card effects that modify turn order or other players' hands
                        // This logic is complex and needs access to the transaction
                        // For simplicity, we are keeping the logic here. A more advanced system
                        // might use a DSL (Domain Specific Language) in JSON.
                    }
                }
            },
            'crazy-eights': {
                name: 'Crazy Eights',
                description: 'Match suit or rank. Eights are wild!',
                minPlayers: 2,
                maxPlayers: 5,
                initialHandSize: 5,
                deck: function() {
                    const deck = [];
                    const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
                    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    for (const suit of SUITS) {
                        for (const rank of RANKS) {
                            deck.push({ suit, rank });
                        }
                    }
                    return deck;
                },
                getDisplayInfo: function(card) {
                    const suitSymbols = { hearts: 'â™¥', diamonds: 'â™¦', clubs: 'â™£', spades: 'â™ ' };
                    const textColor = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'text-red-500' : 'text-black';
                    return {
                        backgroundColor: 'bg-white',
                        content: `<div>${card.rank}<div class="${textColor}">${suitSymbols[card.suit]}</div></div>`,
                        textColor: textColor
                    };
                },
                rules: {
                    isPlayable: function(card, topCard, activeValue) { // activeValue is the current suit
                        return card.rank === '8' || card.suit === activeValue || card.rank === topCard.rank;
                    },
                    getWildCardChoices: function() {
                        return { title: "Choose a suit", choices: [
                            { value: 'hearts', display: 'â™¥', textColor: 'text-red-500' },
                            { value: 'diamonds', display: 'â™¦', textColor: 'text-red-500' },
                            { value: 'clubs', display: 'â™£', textColor: 'text-black' },
                            { value: 'spades', display: 'â™ ', textColor: 'text-black' }
                        ]};
                    },
                    onPlay: async function(transaction, gameState, card, chosenValue, player, playerHandRef, gameRef) {
                        // Crazy Eights has simpler on-play logic in this version
                    }
                }
            }
        };

        // --- GLOBAL STATE & CONFIG ---
        let db, auth, userId, currentGameId = null, gameUnsubscribe = null, handUnsubscribe = null;
        let selectedGameType = null;
        let currentGameDefinition = null;

        const firebaseConfig = {
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT_ID.appspot.com",
            messagingSenderId: "YOUR_SENDER_ID",
            appId: "YOUR_APP_ID"
        };
        const appId = 'default-card-games'; // Changed for the new structure
        
        // --- DOM ELEMENTS ---
        const gameSelectionDiv = document.getElementById('game-selection');
        const gameListDiv = document.getElementById('game-list');
        const lobbyDiv = document.getElementById('lobby');
        const lobbyTitle = document.getElementById('lobby-title');
        const backToSelectionBtn = document.getElementById('back-to-selection');
        const authLoading = document.getElementById('auth-loading');
        const lobbyActions = document.getElementById('lobby-actions');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameBtn = document.getElementById('join-game-btn');
        const gameIdInput = document.getElementById('game-id-input');
        const errorMessage = document.getElementById('error-message');
        const gameBoardDiv = document.getElementById('game-board');
        const playerHandDiv = document.getElementById('player-hand');
        const discardPileDiv = document.getElementById('discard-pile');
        const drawDeckDiv = document.getElementById('draw-deck');
        const drawDeckContent = document.getElementById('draw-deck-content');
        const opponentsArea = document.getElementById('opponents-area');
        const gameIdDisplay = document.getElementById('game-id-display');
        const gameInfo = document.getElementById('game-info');
        const gameLog = document.getElementById('game-log');
        const choicePickerModal = document.getElementById('choice-picker-modal');
        const choiceTitle = document.getElementById('choice-title');
        const choiceButtons = document.getElementById('choice-buttons');
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerText = document.getElementById('winner-text');
        const playAgainBtn = document.getElementById('play-again-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        const loadingModal = document.getElementById('loading-modal');
        const loadingText = document.getElementById('loading-text');

        // --- HELPERS ---
        const generateGameId = () => Math.random().toString(36).substring(2, 7).toUpperCase();
        const showLoading = (text) => { loadingText.textContent = text; loadingModal.classList.remove('hidden'); };
        const hideLoading = () => loadingModal.classList.add('hidden');
        const shuffleDeck = (deck) => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        };

        // --- VIEW MANAGEMENT ---
        function showScreen(screen) {
            [gameSelectionDiv, lobbyDiv, gameBoardDiv].forEach(div => div.classList.add('hidden'));
            screen.classList.remove('hidden');
            if (screen === lobbyDiv || screen === gameBoardDiv) {
                 screen.classList.add('flex');
            }
        }

        function setupGameSelection() {
            gameListDiv.innerHTML = '';
            for (const gameId in GAME_DEFINITIONS) {
                const game = GAME_DEFINITIONS[gameId];
                const button = document.createElement('button');
                button.className = 'bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-6 rounded-lg text-left w-80';
                button.innerHTML = `<div class="text-xl">${game.name}</div><div class="text-sm text-gray-400">${game.description}</div>`;
                button.onclick = () => {
                    selectedGameType = gameId;
                    lobbyTitle.textContent = game.name;
                    showScreen(lobbyDiv);
                };
                gameListDiv.appendChild(button);
            }
        }
        
        // --- FIREBASE & AUTH ---
        async function initializeFirebase() {
            // ... (rest of the logic is refactored below)
            try {
                if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                    errorMessage.textContent = "Please add your Firebase configuration to the html file.";
                    [authLoading, lobbyActions].forEach(el => el.classList.add('hidden'));
                    return;
                }
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authLoading.classList.add('hidden');
                        lobbyActions.classList.remove('hidden');
                    } else {
                        await signInAnonymously(auth);
                    }
                });
            } catch (error) {
                console.error("Firebase Init Error:", error);
                errorMessage.textContent = "Could not connect. Check your Firebase config.";
            }
        }

        // --- UI RENDERING ---
        function renderCard(card, isPlayable = false) {
            const cardEl = document.createElement('div');
            const displayInfo = currentGameDefinition.getDisplayInfo(card);
            cardEl.className = `card-base ${displayInfo.backgroundColor}`;
            cardEl.innerHTML = displayInfo.content;
            
            if (isPlayable) {
                 cardEl.classList.add('cursor-pointer', 'hover:border-yellow-300', 'border-4', 'border-transparent');
            } else {
                cardEl.classList.add('opacity-70', 'cursor-not-allowed');
            }
            return cardEl;
        }

        function updateGameBoard(gameState, playerHand) {
            // This function now uses currentGameDefinition for rules and rendering
            if (!gameState || !playerHand || !currentGameDefinition) return;

            // Render opponents
            opponentsArea.innerHTML = '';
            gameState.players.forEach(p => {
                if (p.uid === userId) return;
                const opponentDiv = document.createElement('div');
                opponentDiv.className = `flex flex-col items-center p-2 rounded-lg ${gameState.currentPlayerUid === p.uid ? 'bg-indigo-800' : ''}`;
                opponentDiv.innerHTML = `<div class="text-sm font-semibold truncate max-w-[80px]">${p.name || 'Player'}</div><div class="flex mt-1">${Array(p.cardCount).fill('<div class="opponent-card ml-[-30px]"></div>').join('')}</div>`;
                opponentsArea.appendChild(opponentDiv);
            });

            // Render discard pile
            const topCard = gameState.discardPile[gameState.discardPile.length - 1];
            discardPileDiv.innerHTML = '';
            const discardCardEl = renderCard(topCard);
            discardCardEl.classList.remove('cursor-pointer');
            discardPileDiv.appendChild(discardCardEl);

            // Render player hand
            playerHandDiv.innerHTML = '';
            const isMyTurn = gameState.currentPlayerUid === userId;
            playerHand.forEach(card => {
                const isPlayable = isMyTurn && currentGameDefinition.rules.isPlayable(card, topCard, gameState.activeValue);
                const cardEl = renderCard(card, isPlayable);
                if (isPlayable) {
                    cardEl.addEventListener('click', () => handlePlayCard(card));
                }
                playerHandDiv.appendChild(cardEl);
            });

            // Update Game Info, Log, and Game Over state
            const currentPlayer = gameState.players.find(p => p.uid === gameState.currentPlayerUid);
            gameInfo.textContent = isMyTurn ? "It's your turn!" : `${currentPlayer?.name || 'Player'}'s turn`;
            gameInfo.classList.toggle('text-yellow-300', isMyTurn);
            gameInfo.classList.toggle('animate-pulse', isMyTurn);

            if(gameState.log?.length) gameLog.textContent = gameState.log[gameState.log.length - 1];

            if (gameState.status === 'finished') {
                const winner = gameState.players.find(p => p.uid === gameState.winner);
                winnerText.textContent = winner.uid === userId ? "You won!" : `${winner.name || 'Player'} won!`;
                gameOverModal.classList.remove('hidden');
            } else {
                gameOverModal.classList.add('hidden');
            }
        }
        
        // --- GAME ACTIONS ---
        async function handleCreateGame() {
            showLoading("Creating Game...");
            const newGameId = generateGameId();
            currentGameId = newGameId;
            currentGameDefinition = GAME_DEFINITIONS[selectedGameType];

            const gameRef = doc(db, `artifacts/${appId}/public/data/games/${newGameId}`);
            const playerHandRef = doc(db, `artifacts/${appId}/users/${userId}/games/${newGameId}`);

            try {
                const deck = shuffleDeck(currentGameDefinition.deck());
                const startingHand = deck.splice(0, currentGameDefinition.initialHandSize);
                let firstCard = deck.pop();
                // Rule for Pixel Cards to avoid starting with wild draw 4
                if(selectedGameType === 'pixel-cards' && firstCard.value === 'wild4') {
                     deck.push(firstCard);
                     shuffleDeck(deck);
                     firstCard = deck.pop();
                }

                const hostPlayer = { uid: userId, name: `Player ${Math.floor(Math.random() * 1000)}`, cardCount: startingHand.length };
                
                const batch = writeBatch(db);
                batch.set(gameRef, {
                    gameType: selectedGameType,
                    players: [hostPlayer],
                    deck: deck,
                    discardPile: [firstCard],
                    currentPlayerUid: userId,
                    activeValue: firstCard.color || firstCard.suit, // Generic active value (color or suit)
                    turnDirection: 1,
                    status: 'waiting',
                    createdAt: serverTimestamp(),
                    log: ["Game created! Waiting for players..."]
                });
                batch.set(playerHandRef, { hand: startingHand });
                await batch.commit();

                await attachGameListeners(newGameId);
                showScreen(gameBoardDiv);
            } catch (error) {
                console.error("Error creating game:", error);
                errorMessage.textContent = "Failed to create game.";
            } finally {
                hideLoading();
            }
        }

        async function handleJoinGame() {
            const gameId = gameIdInput.value.toUpperCase();
            if (!gameId) {
                errorMessage.textContent = "Please enter a Game ID.";
                return;
            }
            showLoading("Joining Game...");

            const gameRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}`);
            try {
                const gameDoc = await getDoc(gameRef);
                if (!gameDoc.exists()) {
                     throw new Error("Game not found!");
                }
                const serverGameType = gameDoc.data().gameType;
                if(serverGameType !== selectedGameType) {
                    throw new Error(`This is a ${GAME_DEFINITIONS[serverGameType].name} game. Go back and select the correct game type to join.`);
                }
                 // ... transaction logic to join ...
                await runTransaction(db, async transaction => {
                    const freshGameDoc = await transaction.get(gameRef);
                    const gameState = freshGameDoc.data();
                    // ... (checks for full game, started game, etc.)
                     const hand = gameState.deck.splice(0, GAME_DEFINITIONS[gameState.gameType].initialHandSize);
                     const newPlayer = { uid: userId, name: `Player ${Math.floor(Math.random() * 1000)}`, cardCount: hand.length};
                     const updatedPlayers = [...gameState.players, newPlayer];
                     const newStatus = updatedPlayers.length >= GAME_DEFINITIONS[gameState.gameType].minPlayers ? 'active' : 'waiting';
                     // ... update game state and player hand
                     transaction.update(gameRef, { players: updatedPlayers, deck: gameState.deck, status: newStatus, log: [...gameState.log, `${newPlayer.name} joined!`] });
                     transaction.set(doc(db, `artifacts/${appId}/users/${userId}/games/${gameId}`), {hand});
                });
                
                currentGameId = gameId;
                await attachGameListeners(gameId);
                showScreen(gameBoardDiv);
            } catch (error) {
                console.error("Error joining game:", error);
                errorMessage.textContent = error.message;
            } finally {
                hideLoading();
            }
        }

        async function handlePlayCard(card) {
            // Simplified for brevity, wild card logic would go here.
             const choices = currentGameDefinition.rules.getWildCardChoices();
             if ((card.color === 'wild' || card.rank === '8') && choices) {
                 choiceTitle.textContent = choices.title;
                 choiceButtons.innerHTML = '';
                 choices.choices.forEach(c => {
                     const btn = document.createElement('button');
                     btn.className = `choice-picker-button ${c.textColor || ''}`;
                     btn.innerHTML = c.display;
                     btn.onclick = () => {
                        processCardPlay(card, c.value);
                        choicePickerModal.classList.add('hidden');
                     }
                     choiceButtons.appendChild(btn);
                 });
                 choicePickerModal.classList.remove('hidden');
                 return;
             }
             const activeValue = card.color || card.suit;
             processCardPlay(card, activeValue);
        }

        async function processCardPlay(card, chosenValue) {
            // This is a highly complex transactional function.
            // It would call currentGameDefinition.rules.onPlay to apply effects.
            // Simplified for this example.
            console.log("Playing card:", card, "with chosen value:", chosenValue);
             const gameRef = doc(db, `artifacts/${appId}/public/data/games/${currentGameId}`);
             const playerHandRef = doc(db, `artifacts/${appId}/users/${userId}/games/${currentGameId}`);
            try {
                await runTransaction(db, async transaction => {
                    // ... get docs, check validity ...
                    // This logic is now generic
                    const gameDoc = await transaction.get(gameRef);
                    const handDoc = await transaction.get(playerHandRef);
                    if (!gameDoc.exists() || !handDoc.exists()) throw new Error("Game state missing");
                    
                    let gameState = gameDoc.data();
                    let playerHand = handDoc.data().hand;
                    const cardIndex = playerHand.findIndex(c => JSON.stringify(c) === JSON.stringify(card));
                    
                    // ... play card, check for winner, apply effects via rules.onPlay ...
                    playerHand.splice(cardIndex, 1);

                    // A simplified turn advance
                    let nextPlayerIndex = (gameState.players.findIndex(p => p.uid === userId) + gameState.turnDirection + gameState.players.length) % gameState.players.length;
                    
                    transaction.update(gameRef, {
                        discardPile: [...gameState.discardPile, card],
                        activeValue: chosenValue,
                        currentPlayerUid: gameState.players[nextPlayerIndex].uid
                        // ... other state changes from card effects
                    });
                    transaction.set(playerHandRef, { hand: playerHand });
                });
            } catch (e) { console.error("Play card failed", e); }
        }

        function handleLeaveGame() {
            if(gameUnsubscribe) gameUnsubscribe();
            if(handUnsubscribe) handUnsubscribe();
            currentGameId = null;
            currentGameDefinition = null;
            showScreen(lobbyDiv);
        }

        async function attachGameListeners(gameId) {
            if (gameUnsubscribe) gameUnsubscribe();
            if (handUnsubscribe) handUnsubscribe();

            const gameRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}`);
            const playerHandRef = doc(db, `artifacts/${appId}/users/${userId}/games/${gameId}`);

            let localPlayerHand = [];

            gameUnsubscribe = onSnapshot(gameRef, (doc) => {
                if (doc.exists()) {
                    const gameState = doc.data();
                    currentGameDefinition = GAME_DEFINITIONS[gameState.gameType];
                    gameIdDisplay.textContent = gameId;
                    drawDeckContent.textContent = currentGameDefinition.name[0];
                    updateGameBoard(gameState, localPlayerHand);
                } else {
                    handleLeaveGame();
                    errorMessage.textContent = "The game has ended or could not be found.";
                }
            });

            handUnsubscribe = onSnapshot(playerHandRef, (doc) => {
                localPlayerHand = doc.data()?.hand || [];
            });
        }
        
        // --- INITIAL SETUP ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
            setupGameSelection();
            showScreen(gameSelectionDiv);

            backToSelectionBtn.addEventListener('click', () => showScreen(gameSelectionDiv));
            createGameBtn.addEventListener('click', handleCreateGame);
            joinGameBtn.addEventListener('click', handleJoinGame);
            leaveGameBtn.addEventListener('click', handleLeaveGame);
            playAgainBtn.addEventListener('click', () => {
                gameOverModal.classList.add('hidden');
                handleLeaveGame();
                showScreen(gameSelectionDiv); // Go all the way back
            });
        });
    </script>
</body>
</html>

